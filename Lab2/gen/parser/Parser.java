package parser;

import beaver.*;
import java.util.ArrayList;

/**
 * This class is a LALR parser generated by
 * <a href="http://beaver.sourceforge.net">Beaver</a> v0.9.6.1
 * from the grammar specification "parser.beaver".
 */
public class Parser extends beaver.Parser {
	static public class Terminals {
		static public final short EOF = 0;
		static public final short ID = 1;
		static public final short LBRACKET = 2;
		static public final short LPAREN = 3;
		static public final short MINUS = 4;
		static public final short STRING_LITERAL = 5;
		static public final short INT_LITERAL = 6;
		static public final short TRUE = 7;
		static public final short FALSE = 8;
		static public final short RPAREN = 9;
		static public final short VOID = 10;
		static public final short BOOLEAN = 11;
		static public final short INT = 12;
		static public final short RCURLY = 13;
		static public final short LCURLY = 14;
		static public final short SEMICOLON = 15;
		static public final short IF = 16;
		static public final short WHILE = 17;
		static public final short BREAK = 18;
		static public final short RETURN = 19;
		static public final short RBRACKET = 20;
		static public final short COMMA = 21;
		static public final short EQL = 22;
		static public final short PUBLIC = 23;
		static public final short PLUS = 24;
		static public final short TIMES = 25;
		static public final short DIV = 26;
		static public final short MOD = 27;
		static public final short TYPE = 28;
		static public final short MODULE = 29;
		static public final short ELSE = 30;
		static public final short IMPORT = 31;
		static public final short EQEQ = 32;
		static public final short NEQ = 33;
		static public final short LT = 34;
		static public final short LEQ = 35;
		static public final short GT = 36;
		static public final short GEQ = 37;
	}

	static final ParsingTables PARSING_TABLES = new ParsingTables(
		"U9orLcbK5MKOVcQ62ruBBW8AWWkH0eAYcK2ee6W4M9ajPfijbhHRsghbGbPgUQf$UKu$#b7" +
		"d#5EjrBB5DijIAyKijMp1pB8Cqt9BtvwP#t8PvixbOfxkFS$tRi$tVUyxCzy2cDcemDMu2H" +
		"TYCgx73RWH9afHXdBqG8uimpISXNmy4CMomYpPWHman6G5NAoa2EigZC7bk1XNe0O3C1hLA" +
		"CPvo48VvAAGqV4QdIg2NfrarybnEOQ#KHair0p#O0R3O#QPgZMdavKHazLTMJt9wXstcapD" +
		"pp$QlyFeZ0wZzqT5htEYqPvn#dIoKOdBFDLS8pinebsVivq#7fwyqeupAcgcywCy4w8yKw8" +
		"yz$hDXOl2#Se13CI3xVWF#VAzzgrn6VOJ3A51t#H4N8b9oCDjk1rtu4xSXRlZZd2wTWhweH" +
		"iI4TJP2t06paGoYXXv35tGbH4xoxber4WjXg64rYpD#XBMsOWqjIx0BPWfl#Xt$YhcXtjpD" +
		"OnbdTUYIlPWCAemct8X1c48pi6v6Ced$2WMIGj6KjPpp7fSoXLIYvjn3nx6TDmdl#8Hp96z" +
		"yZFcSVqyZYVn19x20ZmDWxk4nNKVO1r9pBatimxdci9nKbbV6jUIbsMuM2anMMDThEG8Av$" +
		"FgP2he8ZL3MGL9Qp9hcGeQndMBWfMr5bsClyZepB8r0mCPc35hIROOJLZN6Fzbsh#xsXiJu" +
		"XxXhUQIjPGvzF7omkUqaodvl7ErSgm$Q5EyBrsGbn6#0bcwPlioTqqX$5Sxlzvt3FxSI#FD" +
		"yBfsgLyeXPNTONE7k9wjdVY42CXxi1s99obeP4onpQueiDPcqwTrMhLSDUevPYjNt0lxPtC" +
		"Kp#B9s1t#aosmoapQMUmRmOzjgylzI1bEQroUYtEPMSNOjk76C5$a7$3#GSuei5OYEjoyJm" +
		"s8hAF8fj8jst0#8vD0J4#R7FV1oRPUYl8sSYcaN8riOFwR6AMZYTjF2mXcbLF8vvHlJ$Hec" +
		"FDONEGSZbbW$fMkEPQgRAUQ2Qc4ot4Rk88SPJOevnZdZnFifb1cKGSLjykOgA7znKnMVKfA" +
		"Xk8gSGqjHUqyKs3zhF40RKjvRpi7bTzpnCxlNvN$4L2L5zAR8l5TSsVIDuoIfF6JEhxeU#J" +
		"UgNAuyfDeBwNqdu6JSHlrBiGtJIUfZATi6Kg4NJDrOFeschpzQvpwVnsZFcUUfxpgR7EfR$" +
		"GflC#eTzDT9$mzwXwaIUsNUMY#C$AU2aUnsVkLHvxdm$daBiU$YgeRw1Sh$vS3$#4JswRVC" +
		"PT6wUUH1StZ$RcpjLaXBJF4fLBrL$WmsrIkOROsfdn$UV4OkXFJiYVZZnfIpagH#GmN3$vX" +
		"lXRldNqtKxRxBG$HXW$4DyBToVP1S$F$Wvbl$mk$BPbY#DPuxGhv4lPAczIQv9DyZdbHyJx" +
		"nDlobksdzeLiaSsoJjwLjVAElEVutf3byhgibbMoqh5V8pwJ3#K3sIWRv5FvHDRBnv7PjnD" +
		"V4zn5P9idiv#8loBM8Jdeo7$OJE3TB97tAvC0JmtxH349#qio8gZYtZsAfyLeSajfbp9kdo" +
		"kj6Ep247AhdNC5F4zCxlmM0PuR9cySbi8W0eIfkibRaGtxfcOIuDqaG2JnXc8I5azkmy4Ww" +
		"WMKDWgPKmdZDGx04ypmHJ7x55EMAOfe5r6Mkv3FCV8f1pX882pLtR1urp48yDvZERUXSVy2" +
		"AtGRvm==");

	static final Action RETURN6 = new Action() {
		public Symbol reduce(Symbol[] _symbols, int offset) {
			return _symbols[offset + 6];
		}
	};

	static final Action RETURN2 = new Action() {
		public Symbol reduce(Symbol[] _symbols, int offset) {
			return _symbols[offset + 2];
		}
	};

	static final Action RETURN3 = new Action() {
		public Symbol reduce(Symbol[] _symbols, int offset) {
			return _symbols[offset + 3];
		}
	};

	static final Action RETURN9 = new Action() {
		public Symbol reduce(Symbol[] _symbols, int offset) {
			return _symbols[offset + 9];
		}
	};

	static final Action RETURN4 = new Action() {
		public Symbol reduce(Symbol[] _symbols, int offset) {
			return _symbols[offset + 4];
		}
	};

	static final Action RETURN5 = new Action() {
		public Symbol reduce(Symbol[] _symbols, int offset) {
			return _symbols[offset + 5];
		}
	};

	static final Action RETURN7 = new Action() {
		public Symbol reduce(Symbol[] _symbols, int offset) {
			return _symbols[offset + 7];
		}
	};

	// turn off automated error recovery
	@Override
	protected void recoverFromError(Symbol token, TokenStream in) throws java.io.IOException, Exception {
		super.recoverFromError(new Symbol(0), in);
	}

	private final Action[] actions;

	public Parser() {
		super(PARSING_TABLES);
		actions = new Action[] {
			RETURN6,	// [0] Module = MODULE ID LCURLY imports declarations RCURLY; returns 'RCURLY' although none is marked
			RETURN2,	// [1] imports = imports import; returns 'import' although none is marked
			Action.NONE,  	// [2] imports = 
			RETURN3,	// [3] import = IMPORT ID SEMICOLON; returns 'SEMICOLON' although none is marked
			RETURN2,	// [4] declarations = declaration declarations; returns 'declarations' although none is marked
			Action.NONE,  	// [5] declarations = 
			Action.RETURN,	// [6] declaration = funcdecl
			Action.RETURN,	// [7] declaration = fielddecl
			Action.RETURN,	// [8] declaration = typedecl
			RETURN9,	// [9] funcdecl = accessibility typename ID LPAREN paramlist RPAREN LCURLY statements RCURLY; returns 'RCURLY' although none is marked
			RETURN4,	// [10] fielddecl = accessibility typename ID SEMICOLON; returns 'SEMICOLON' although none is marked
			RETURN6,	// [11] typedecl = accessibility TYPE ID EQL STRING_LITERAL SEMICOLON; returns 'SEMICOLON' although none is marked
			Action.RETURN,	// [12] accessibility = PUBLIC
			Action.NONE,  	// [13] accessibility = 
			Action.RETURN,	// [14] typename = primitivetype
			Action.RETURN,	// [15] typename = arraytype
			Action.RETURN,	// [16] typename = ID
			Action.RETURN,	// [17] primitivetype = VOID
			Action.RETURN,	// [18] primitivetype = BOOLEAN
			Action.RETURN,	// [19] primitivetype = INT
			RETURN9,	// [20] arraytype = primitivetype LBRACKET RBRACKET arraytype LBRACKET RBRACKET ID LBRACKET RBRACKET; returns 'RBRACKET' although none is marked
			Action.RETURN,	// [21] paramlist = nonEmptyParList
			Action.NONE,  	// [22] paramlist = 
			RETURN2,	// [23] nonEmptyParList = param paramLTail; returns 'paramLTail' although none is marked
			RETURN3,	// [24] paramLTail = COMMA param paramLTail; returns 'paramLTail' although none is marked
			Action.NONE,  	// [25] paramLTail = 
			RETURN2,	// [26] param = typename ID; returns 'ID' although none is marked
			RETURN3,	// [27] statement = typename ID SEMICOLON; returns 'SEMICOLON' although none is marked
			RETURN3,	// [28] statement = LCURLY statementlist RCURLY; returns 'RCURLY' although none is marked
			Action.RETURN,	// [29] statement = ifStatement
			RETURN5,	// [30] statement = WHILE LPAREN expression RPAREN statement; returns 'statement' although none is marked
			RETURN2,	// [31] statement = BREAK SEMICOLON; returns 'SEMICOLON' although none is marked
			Action.RETURN,	// [32] statement = returnStatement
			RETURN2,	// [33] statement = expression SEMICOLON; returns 'SEMICOLON' although none is marked
			RETURN2,	// [34] statements = statements statement; returns 'statement' although none is marked
			Action.NONE,  	// [35] statements = 
			RETURN2,	// [36] statementlist = statement statementlist; returns 'statementlist' although none is marked
			Action.NONE,  	// [37] statementlist = 
			RETURN5,	// [38] ifStatement = IF LPAREN expression RPAREN statement; returns 'statement' although none is marked
			RETURN7,	// [39] ifStatement = IF LPAREN expression RPAREN statement ELSE statement; returns 'statement' although none is marked
			RETURN2,	// [40] returnStatement = RETURN SEMICOLON; returns 'SEMICOLON' although none is marked
			RETURN3,	// [41] returnStatement = RETURN expression SEMICOLON; returns 'SEMICOLON' although none is marked
			Action.RETURN,	// [42] expression = assignment
			Action.RETURN,	// [43] expression = rhsExpression
			RETURN3,	// [44] assignment = lhsExpression EQL expression; returns 'expression' although none is marked
			Action.RETURN,	// [45] lhsExpression = ID
			Action.RETURN,	// [46] lhsExpression = arrayAccess
			RETURN4,	// [47] arrayAccess = lhsExpression LBRACKET expression RBRACKET; returns 'RBRACKET' although none is marked
			RETURN2,	// [48] rhsExpression = arithExpression optionalArith; returns 'optionalArith' although none is marked
			RETURN2,	// [49] optionalArith = compOp arithExpression; returns 'arithExpression' although none is marked
			Action.NONE,  	// [50] optionalArith = 
			Action.RETURN,	// [51] compOp = EQEQ
			Action.RETURN,	// [52] compOp = NEQ
			Action.RETURN,	// [53] compOp = LT
			Action.RETURN,	// [54] compOp = LEQ
			Action.RETURN,	// [55] compOp = GT
			Action.RETURN,	// [56] compOp = GEQ
			new Action() {	// [57] arithExpression = arithExpression addOp term
				public Symbol reduce(Symbol[] _symbols, int offset) {
					((ArrayList) _symbols[offset + 1].value).add(_symbols[offset + 3]); return _symbols[offset + 1];
				}
			},
			new Action() {	// [58] arithExpression = term
				public Symbol reduce(Symbol[] _symbols, int offset) {
					ArrayList lst = new ArrayList(); lst.add(_symbols[offset + 1]); return new Symbol(lst);
				}
			},
			Action.RETURN,	// [59] addOp = PLUS
			Action.RETURN,	// [60] addOp = MINUS
			new Action() {	// [61] term = term mulOp factor
				public Symbol reduce(Symbol[] _symbols, int offset) {
					((ArrayList) _symbols[offset + 1].value).add(_symbols[offset + 3]); return _symbols[offset + 1];
				}
			},
			new Action() {	// [62] term = factor
				public Symbol reduce(Symbol[] _symbols, int offset) {
					ArrayList lst = new ArrayList(); lst.add(_symbols[offset + 1]); return new Symbol(lst);
				}
			},
			Action.RETURN,	// [63] mulOp = TIMES
			Action.RETURN,	// [64] mulOp = DIV
			Action.RETURN,	// [65] mulOp = MOD
			RETURN2,	// [66] factor = MINUS factor; returns 'factor' although none is marked
			Action.RETURN,	// [67] factor = primExpression
			Action.RETURN,	// [68] primExpression = lhsExpression
			RETURN4,	// [69] primExpression = ID LPAREN expressionList RPAREN; returns 'RPAREN' although none is marked
			RETURN3,	// [70] primExpression = LBRACKET nonEmptyExpressionList RBRACKET; returns 'RBRACKET' although none is marked
			Action.RETURN,	// [71] primExpression = STRING_LITERAL
			Action.RETURN,	// [72] primExpression = INT_LITERAL
			Action.RETURN,	// [73] primExpression = TRUE
			Action.RETURN,	// [74] primExpression = FALSE
			RETURN3,	// [75] primExpression = LPAREN expression RPAREN; returns 'RPAREN' although none is marked
			Action.RETURN,	// [76] expressionList = nonEmptyExpressionList
			Action.NONE,  	// [77] expressionList = 
			new Action() {	// [78] nonEmptyExpressionList = nonEmptyExpressionList COMMA expression
				public Symbol reduce(Symbol[] _symbols, int offset) {
					((ArrayList) _symbols[offset + 1].value).add(_symbols[offset + 3]); return _symbols[offset + 1];
				}
			},
			new Action() {	// [79] nonEmptyExpressionList = expression
				public Symbol reduce(Symbol[] _symbols, int offset) {
					ArrayList lst = new ArrayList(); lst.add(_symbols[offset + 1]); return new Symbol(lst);
				}
			}
		};
	}

	protected Symbol invokeReduceAction(int rule_num, int offset) {
		return actions[rule_num].reduce(_symbols, offset);
	}
}
